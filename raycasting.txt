Algo Digital Differential Analysis

FOV = field of view

length of ray from current position to next x or y-side
sideDistX;
sideDistY;

length of ray from one x or y-side to next x or y-side
deltaDistX = sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
deltaDistY = sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))

int hit = 0; //was there a wall hit?
int side; //was a NS or a EW wall hit?

perpWallDist

what direction to step in x or y-direction (either +1 or -1)
int stepX;
int stepY;


Textures

texX is the x-coordinate of the texture and texY the y-coordinate

int texX = int(wallX * double(texWidth));
if(side == 0 && rayDirX > 0)
	texX = texWidth - texX - 1;
if(side == 1 && rayDirY < 0)
	texX = texWidth - texX - 1;

// How much to increase the texture coordinate per screen pixel
double step = 1.0 * texHeight / lineHeight;
// Starting texture coordinate
double texPos = (drawStart - h / 2 + lineHeight / 2) * step;
for (int y = drawStart; y<drawEnd; y++)
{
	// Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
	int texY = (int)texPos & (texHeight - 1);
	texPos += step;
	Uint32 color = texture[texNum][texHeight * texY + texX];
	//make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
	if(side == 1) color = (color >> 1) & 8355711;
	buffer[y][x] = color;
}

mlx_image_t* mlx_texture_to_image(mlx_t* mlx, mlx_texture_t* texture);

/**
 * Base object for disk loaded textures.
 * It contains rudementary information about the texture.
 * 
 * @param width The width of the texture.
 * @param height The height of the texture.
 * @param pixels The literal pixel data.
 * @param bytes_per_pixel The amount of bytes in a pixel, always 4.
 */
typedef struct mlx_texture
{
	uint32_t	width;
	uint32_t	height;
	uint8_t		bytes_per_pixel;
	uint8_t*	pixels;
}	mlx_texture_t;

/**
 * An image with an individual buffer that can be rendered.
 * Any value can be modified except the width/height and context.
 * 
 * @param width The width of the image.
 * @param height The height of the image.
 * @param pixels The literal pixel data.
 * @param instances An instance carrying the X, Y and Z location data.
 * @param count The element count of the instances array.
 * @param enabled If true the image is drawn onto the screen, else it's not.
 * @param context Abstracted OpenGL data.
 */
typedef struct mlx_image
{
	const uint32_t	width;
	const uint32_t	height;
	uint8_t*		pixels;
	mlx_instance_t*	instances;
	size_t			count;
	bool			enabled;
	void*			context;
}	mlx_image_t;





VIDEO

Degre = 	0		90		180 	360
Radian = 	2pi		pi/2	pi		3pi/2

pdx = player delta x
pdy = player delta y
pa = player angle

float px, py, pdx, pdy, pa

if (key == a)
{
	pa -= 0.1;
	if (pa < 0)
		pa += 2 * pi;
	pdx = cos(pa) * 5;
	pdy = sin(pa) * 5;
}
if (key == d)
{
	pa += 0.1;
	if (pa > 2 * pi)
		pa -= 2 * pi;
	pdx = cos(pa) * 5;
	pdy = sin(pa) * 5;
}
if (key == w)
{
	px += pdx;
	py += pdy;
}
if (key == s)
{
	px -= pdx;
	py -= pdy;
}

void init()
{
	pdx = cos(pa) * 5;
	pdy = sin(pa) * 5;
}